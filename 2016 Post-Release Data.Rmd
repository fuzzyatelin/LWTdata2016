---
title: "2016 Post-Release Data"
output: html_document
---

# Full Post-Release Dataset

## Importing the dataset
```{r}
post_focals<- curl("https://raw.githubusercontent.com/langley1/LWTdata2016/main/2016_post-release_focals_FULL.csv") #this is FULL dataset
post_focals<- read.csv(post_focals, header = T, na.strings=c(""," ","NA"))
head(post_focals)

post_cont<- curl("https://raw.githubusercontent.com/langley1/LWTdata2016/main/2016_post-release_cont_FULL.csv")
post_cont<- read.csv(post_cont, header = T, na.strings=c(""," ","NA"))
head(post_cont)
```

*Editing Continuous dataset*
```{r}
post_cont<- post_cont %>%
  filter(!ASSOCIATION %in% c("BB","MY","MT","I","ZI"), #removing the infants from association because they were never observed as focals and have very little data in general
         FOCAL.ID != "ZI") #removing ZI because he has very little data and left a few days after release

#Stage 1 post-release
post_cont_1<- post_cont %>%
  filter(MONTH %in% c("4","5")) #looking at the first two full months post-release to assess dominance heirarchy and rank, month 3 was removed to give an adjustment period (this is all before the first individual dies, Jack)
  
#Stage 2 post-release
post_cont_2<- post_cont %>%
  filter(MONTH %in% c("6","7","8"))

#Stage 3 post-release
post_cont_3<- post_cont %>%
  filter(MONTH %in% c("9","10","11"))
```

## Post-Release Rank Determination

### For stage 1
*Combining displacement, agression, and threat into one matrix (focal WINS all of these interactions)*
```{r}
# 1. Create a character vector of all the monkey IDs in your dataset:
post_monkeyIDs1<-as.character(unique(post_cont_1$FOCAL.ID))

# 2. Get a list of dataframes, subsetted by monkey ID:
post_monkey.prelim1<-lapply(post_monkeyIDs1, function(x){post_cont_1[post_cont_1[["FOCAL.ID"]] == x, ]})
head(post_monkey.prelim1)

post_monkey_ALL.prelim1<-
  post_monkey.prelim1 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="1")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim1) <- post_monkeyIDs1

post_monkeylist1<-list(actor=post_monkeyIDs1,recipient=post_monkeyIDs1) #create list of all possible actors/recipients
post_filt1 <- function(x, y) {x == y} #create function to filter out same-monkey pairs ("FZ grooms FZ")
post_combo1 <- post_monkeylist1 %>% cross_df(.,.filter=post_filt1) #get the filtered combined list as a dataframe

post_combo_ALL1<-
  post_combo1 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim1),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim1[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL1<-post_combo_ALL1 %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim1 %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL1

post_ALL_matrix1<-spread(post_ALL1,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix1
```

*Combining displacement, agression, and threat into one matrix (focal LOSES all of these interactions)*
```{r}
post_monkey_ALL.prelim1_lose<-
  post_monkey.prelim1 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="2")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim1_lose) <- post_monkeyIDs1

post_combo_ALL1_lose<-
  post_combo1 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim1_lose),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim1_lose[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL1_lose<-post_combo_ALL1_lose %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim1_lose %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL1_lose

post_ALL_matrix1_lose<-spread(post_ALL1_lose,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix1_lose
```

### For stage 2
*Combining displacement, agression, and threat into one matrix (focal WINS all of these interactions)*
```{r}
post_monkeyIDs2<-as.character(unique(post_cont_2$FOCAL.ID))

post_monkey.prelim2<-lapply(post_monkeyIDs2, function(x){post_cont_2[post_cont_2[["FOCAL.ID"]] == x, ]})
head(post_monkey.prelim2)

post_monkey_ALL.prelim2<-
  post_monkey.prelim2 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="1")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim2) <- post_monkeyIDs2

post_monkeylist2<-list(actor=post_monkeyIDs2,recipient=post_monkeyIDs2) #create list of all possible actors/recipients
post_filt2 <- function(x, y) {x == y} #create function to filter out same-monkey pairs ("FZ grooms FZ")
post_combo2 <- post_monkeylist2 %>% cross_df(.,.filter=post_filt2) #get the filtered combined list as a dataframe

post_combo_ALL2<-
  post_combo2 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim2),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim2[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL2<-post_combo_ALL2 %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim2 %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL2

post_ALL_matrix2<-spread(post_ALL2,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix2
```

*Combining displacement, agression, and threat into one matrix (focal LOSES all of these interactions)*
```{r}
post_monkey_ALL.prelim2_lose<-
  post_monkey.prelim2 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="2")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim2_lose) <- post_monkeyIDs2

post_combo_ALL2_lose<-
  post_combo2 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim2_lose),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim2_lose[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL2_lose<-post_combo_ALL2_lose %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim2_lose %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL2_lose

post_ALL_matrix2_lose<-spread(post_ALL2_lose,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix2_lose
```

### For stage 3
*Combining displacement, agression, and threat into one matrix (focal WINS all of these interactions)*
```{r}
post_monkeyIDs3<-as.character(unique(post_cont_3$FOCAL.ID))

post_monkey.prelim3<-lapply(post_monkeyIDs3, function(x){post_cont_3[post_cont_3[["FOCAL.ID"]] == x, ]})
head(post_monkey.prelim3)

post_monkey_ALL.prelim3<-
  post_monkey.prelim3 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="1")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim3) <- post_monkeyIDs3

post_monkeylist3<-list(actor=post_monkeyIDs3,recipient=post_monkeyIDs3) #create list of all possible actors/recipients
post_filt3 <- function(x, y) {x == y} #create function to filter out same-monkey pairs ("FZ grooms FZ")
post_combo3 <- post_monkeylist3 %>% cross_df(.,.filter=post_filt3) #get the filtered combined list as a dataframe

post_combo_ALL3<-
  post_combo3 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim3),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim3[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL3<-post_combo_ALL3 %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim3 %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL3

post_ALL_matrix3<-spread(post_ALL3,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix3
```

*Combining displacement, agression, and threat into one matrix (focal LOSES all of these interactions)*
```{r}
post_monkey_ALL.prelim3_lose<-
  post_monkey.prelim1 %>%
  purrr::map(~filter(.,BEHAVIOUR %in% c("A+","A-","MP+", "TH+","TH-"), CONFLICT.OUTCOME=="2")) %>% 
  purrr::map(~group_by(.,ASSOCIATION)) %>%
  purrr::map(~summarize(.,count=n()))
names(post_monkey_ALL.prelim3_lose) <- post_monkeyIDs3

post_combo_ALL3_lose<-
  post_combo3 %>%
  mutate(absent1 = map2_chr(
    actor,
    recipient,
    ~if_else(.x %in% names(post_monkey_ALL.prelim3_lose),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    actor,
    recipient,
    ~if_else(.y %in% post_monkey_ALL.prelim3_lose[[.x]]$ASSOCIATION,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

post_ALL3_lose<-post_combo_ALL3_lose %>% 
  mutate(interaction = map2_int(
    actor, 
    recipient, 
    ~post_monkey_ALL.prelim3_lose %>% pluck(.x) %>% filter(ASSOCIATION==.y) %>% as.data.frame(.) %>% .[,2]))
post_ALL3_lose

post_ALL_matrix3_lose<-spread(post_ALL3_lose,recipient,interaction) %>% column_to_rownames(var="actor") %>% data.matrix()
post_ALL_matrix3_lose
```

RESULTS: Based on all agonistic behaviors, the dominance hierarchy in the troop appears stable. There is no evidence suggesting a major change in dominance order from the pre-release stage. There is also no evidence suggesting a wild male took over as the highest ranking individual. Pops remains the highest ranking male and Blue remains the highest ranking female throughout all stages of the post-release period. 

## Mortality by Month

*Creating a data frame for mortality by month*
```{r}
month<- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sept","Oct","Nov","Dec")
confirmed_death<- c(0,0,0,0,0,1,0,3,2,0,1,1)
assumed_death<- c(0,0,0,2,0,0,0,2,0,2,1,1)

mortality_cal<- data.frame(month,confirmed_death,assumed_death)
mortality_cal<- mortality_cal %>%
  rowwise() %>%
  mutate(total = sum(c_across(confirmed_death:assumed_death))) #including a column at the end with total confirmed and assumed deaths per month

mortality_cal2<- curl("https://raw.githubusercontent.com/langley1/LWTdata2016/main/Mortality%20Cal.csv") #created my own df in excel
mortality_cal2<- read.csv(mortality_cal2, header = T, na.strings=c(""," "))
```

*Creating a plot that shows mortality in each month*
```{r}
library(ggplot2)
#this version uses the dataframe that I made by hand in r, was having trouble stacking the assumed and confirmed deaths
mortalitycal_plot<- ggplot(data=mortality_cal, aes(x=month, y=, fill=confirmed_death)) +
  geom_bar(stat="identity") +
  scale_x_discrete(limits=mortality_cal$month) #this stops ggplot from ordering my months alphabetically 
mortalitycal_plot

#this version uses the dataframe I made using an excel datasheet 
mortalitycal_plot<- ggplot(data=mortality_cal2, aes(x=Month, y=Death, fill=Type.Death, yName = "Number of Deaths")) + #fill= Type.Death so I can stack assumed and confirmed deaths for each month
  geom_bar(stat="identity", width= 0.9) +
  scale_x_discrete(limits=mortality_cal2$Month) + #this stops ggplot from ordering my months alphabetically 
  scale_fill_discrete(name = "Death Type", labels = c("Assumed Dead", "Confirmed Dead")) +
  scale_fill_brewer(palette = "Reds") + theme_minimal()
mortalitycal_plot #this looks good but the months are unevenly spaced, possibly due to longer/shorter months??

#trying code I found online to fix the uneven spacing for months
niceFormatting <- format(mortality_cal2$Month, "%b") # %b is supposed to be for noting abbreviated months but I get an error with this 
MonthFactor <- factor(niceFormatting, levels = niceFormatting)

#also tried turning month column in characters to see if that helps 
mortality_cal2 %>% mutate_if(is.factor, as.character) -> mortality_cal2
str(mortality_cal2)
```

## Exploring Position in Canopy

### Bar Plots
```{r}
# Looking at position in canopy grouped by sex (M/F)
PIC_plot<- post_focals %>% 
  drop_na(POSITION.IN.CANOPY) %>% #removing all NAs in this column so they don't show up on graph
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>% #This is to re-order the x-axis so that I can have MMS and NS at the end rather than right in the middle 
    ggplot( aes(POSITION.IN.CANOPY, group = SEX)) +
    geom_bar(aes(y = ..prop..), stat="count") + 
    scale_y_continuous(labels=scales::percent) +
    theme(axis.text.x = element_text(angle = 45, hjust =1)) +
    ylab("Percentage Recorded in Canopy Position") +
    xlab("Position in Canopy") +
    facet_grid(~SEX)
PIC_plot

# Looking at position in canopy grouped by age (A/SA/J)
age_PIC_plot<- post_focals %>% 
  drop_na(POSITION.IN.CANOPY) %>% #removing all NAs in this column so they don't show up on graph
  filter(AGE != "I") %>% #removing infants
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>% #This is to re-order the x-axis so that I can have MMS and NS at the end rather than right in the middle 
    ggplot( aes(POSITION.IN.CANOPY, group = AGE)) +
    geom_bar(aes(y = ..prop..), stat="count") + 
    theme(axis.text.x = element_text(angle = 45, hjust =1)) +
    scale_y_continuous(labels=scales::percent) +
    ylab("Percentage Recorded in Canopy Position") +
    xlab("Position in Canopy") +
    facet_grid(~AGE)
age_PIC_plot

# Looking at position in canopy of females only, grouped by age (I took out infants)
fems_PIC_plot<- post_focals %>% 
  drop_na(POSITION.IN.CANOPY) %>% #removing all NAs in this column so they don't show up on graph
  filter(SEX == "F", AGE %in% c("A","J")) %>% #filtering out females and adults/juveniles (no infants)
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>% #This is to re-order the x-axis so that I can have MMS and NS at the end rather than right in the middle
  ggplot( aes(POSITION.IN.CANOPY, group = AGE)) +
  geom_bar(aes(y = ..prop..), stat="count") + 
  scale_y_continuous(labels=scales::percent) +
  scale_fill_manual(values = c("G"= "black","LC1"= "orange","LC2"= "blue","MC1"= "black","MC2"= "orange","TC1"= "blue","TC2" ="black","TC3"= "orange","MMS"= "blue","NS1"= "black")) + #This color code DOESN'T WORK
  facet_grid(~AGE) +
  ylab("Percentage Recorded in Canopy Position") +
  xlab("Position in Canopy")
fems_PIC_plot

#Pops, Jack, Mango (adult/SA males) from March-May because Jack dies in June
Males_canopy_test<- post_focals %>% filter(FOCAL.ID %in% c("PO","JA","MG"), MONTH %in% c("3","4","5")) %>% drop_na(POSITION.IN.CANOPY)
str(Males_canopy_test)                                                                      
#This one looks strange by the x-axis
ggplot(Males_canopy_test, aes(POSITION.IN.CANOPY, fill = factor(FOCAL.ID))) +
  geom_bar(position = position_dodge2(preserve = "single")) +
  geom_bar(aes(y = ..prop..), stat="count") + 
  scale_y_continuous(labels=scales::percent) +
  ylab("prop")

#Super high percentages on y-axis
ggplot(Males_canopy_test, aes(POSITION.IN.CANOPY, fill = factor(FOCAL.ID))) +
  geom_bar(position = position_dodge2(preserve = "single")) +
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  scale_y_continuous(labels=scales::percent) +
  ylab("prop")

#aes(y = ..prop.., group = 1), stat="count", 

par(mfrow=c(2,2))
PIC_plot
age_PIC_plot
fems_PIC_plot
```

RESULTS: Overall, both males and females were most frequently positioned on the ground during post-release monitoring (Figure PIC_plot). They were also located in the lower and middle tree canopies more often than top canopies (Figure PIC_plot). Out of the three canopy levels (LC,MC,TC), all individuals were located in the lowest height category (1) most often, remaining 5m or less above the ground, and were rarely seen higher up in the canopy (2,3).  

RESULTS: All age groups of both sexes were most frequently positioned on the ground and in lower and middle tree canopies, less than 5m above the ground (Figure age_PIC_plot). Out of the three canopy levels, all individuals across age groups were positioned in the top canopy least often and rarely moved up higher than 5m above the ground in any canopy level (Figure age_PIC_plot).


## Density Plots
```{r}
#Density plot with adult females only
fems_denPIC_plot<- ggplot((post_focals %>% filter(SEX == "F", AGE == "A") %>%
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>%
  drop_na(POSITION.IN.CANOPY)), aes(x = POSITION.IN.CANOPY)) +  
  geom_density(aes(group = FOCAL.ID, 
                   colour = FOCAL.ID, 
                   fill = FOCAL.ID),
               alpha = 0.2)
fems_denPIC_plot

post_focals %>% filter(POSITION.IN.CANOPY == "Mc1")

#density plot with adult males only
males_denPIC_plot<- ggplot((post_focals %>% filter(SEX == "M",AGE == "A",FOCAL.ID != "PA") %>% #Taking out Patches because he only had 2 focals
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>%                         
  drop_na(POSITION.IN.CANOPY)), aes(x = POSITION.IN.CANOPY)) +  
  geom_density(aes(group = FOCAL.ID, 
                   colour = FOCAL.ID, 
                   fill = FOCAL.ID),
               alpha = 0.2)
males_denPIC_plot

#Density plot with subadult and juveniles (males/fems)
age_denPIC_plot<- ggplot((post_focals %>% filter(AGE %in% c("SA","J"), FOCAL.ID != "RE") %>% #Taking out Red because she only had 2 focal observations
  mutate(POSITION.IN.CANOPY = fct_relevel(POSITION.IN.CANOPY, "G", "LC1", "LC2", "MC1", "MC2", "TC1", "TC2", "TC3", "MMS", "NS1")) %>%
  drop_na(POSITION.IN.CANOPY)), aes(x = POSITION.IN.CANOPY)) +  
  geom_density(aes(group = FOCAL.ID, 
                   colour = FOCAL.ID, 
                   fill = FOCAL.ID),
               alpha = 0.2)
age_denPIC_plot

par(mfrow=c(3,1))
fems_denPIC_plot
males_denPIC_plot
age_denPIC_plot
```

METHODS: Density plots were created in ggplot to show the probability density of each indiviudals position in the canopy throughout the post-release stage.

RESULTS: Cicero and Homer, the two wild males that joined the troop for some time, were positioned in the top canopy more than all other adult males (Figure males_denPIC_plot). Cicero was positioned higher up in the top canopy (5-10m off the ground) more often than all other adult males and was positioned on the ground less than all other adult males (Figure). 

## Survival Analysis

Note: Red only has a few focals post-release (march/april) but in the demographics file it says she's assumed dead October 4th, Skittles only has 1 focal early on but it says he's assumed dead in November... so not sure if this date is incorrect but they have been removed for this analysis. Also, Alex and Augustine are declared dead AFTER their last data entry (Nov 1st) but I put Nov 1st in their "Date End" column and gave them a status of 2, which means dead.

## Survival Analysis FULL 
```{r}
library(survival)
library(survminer)

#STEP 1:
post_focals_surv<- curl("https://raw.githubusercontent.com/langley1/LWTdata2016/main/2016_post-release_focals_SURV.csv") #inputting my post focals dataset with data in my "Date End" column 
post_focals_surv<- read.csv(post_focals_surv, header = T, na.strings=c(""," ","NA"))

#STEP 2:
post_focals_surv$Date.End <- as.Date(post_focals_surv$Date.End, format = "%Y-%m-%d") #telling R that my "Date End" column is in the y-m-d format and that it needs to be read as "Date" rather than "Factor"

post_focals_surv<- post_focals_surv %>% 
  unite(Date, c(DAY, MONTH, YEAR), sep = "-", remove = FALSE) %>% #Creating a new column called "Date" using unite(), which combines Day, Month, and Year columns with - as separator
  mutate(Date = as.Date(Date, format = "%d-%m-%Y")) #using mutate() to turn my date column into accecptable "date" format. NOTE: the format I use in this code is what format my original column IS in...R then turns it into standard Y-M-D format, which will match my "Date End" column 

#STEP 3:
post_focals_surv<- post_focals_surv %>% filter(!FOCAL.ID %in% c("CI","HO","PA","ZI")) %>% #filtering out these individuals because they are wild males
  droplevels() %>% #takes the IDs I want to remove from the levels as well 
  group_by(FOCAL.ID) %>%
  mutate( #creating a new column called "days_surv"
    days_surv = 
      as.numeric( 
        difftime(Date.End[1], #only selecting the first cell in "Date.End" and "Date" so that it calcultes the difference from the first day of data collection to the day I entered into "Date.End", which is the last day they were observed
                 Date[1],
                 units = "days"))) #number of days survived

#STEP 4: status 1 = survived or emigrated; status 2 = confirmed or assumed dead
post_focals_surv<- post_focals_surv %>% 
  mutate(status = #creating a new column called "status" to label individuals who die vs those who survive
    case_when(FOCAL.ID %in% c("PO","MG","BL","AM","KO","ED","MA") ~ as.numeric(1), #for these individuals status=1
              FOCAL.ID %in% c("JA","NE","AL","TO","AU","BO","BM","TI","SK","RE") ~ as.numeric(2))) #for these indivduals status=2

#STEP 5: adding in social rank column 
post_focals_surv<- post_focals_surv %>%
  mutate(rank =
    case_when(FOCAL.ID == "PO" ~ as.numeric(1),
              FOCAL.ID == "BL" ~ as.numeric(2),
              FOCAL.ID == "AM" ~ as.numeric(3),
              FOCAL.ID == "AL" ~ as.numeric(4),
              FOCAL.ID == "TO" ~ as.numeric(5),
              FOCAL.ID == "AU" ~ as.numeric(6),
              FOCAL.ID == "BO" ~ as.numeric(7),
              FOCAL.ID == "JA" ~ as.numeric(8),
              FOCAL.ID == "MG" ~ as.numeric(9),
              FOCAL.ID == "RE" ~ as.numeric(10),
              FOCAL.ID == "ED" ~ as.numeric(11),
              FOCAL.ID == "MA" ~ as.numeric(12),
              FOCAL.ID == "SK" ~ as.numeric(13),
              FOCAL.ID == "BM" ~ as.numeric(14),
              FOCAL.ID == "NE" ~ as.numeric(15),
              FOCAL.ID == "KO" ~ as.numeric(16),
              FOCAL.ID == "TI" ~ as.numeric(17)))

#STEP 6: select only the first row for each focal ID and clean up dataframe
post_surv_edited<-
post_focals_surv %>% 
  group_by(FOCAL.ID) %>% 
  filter(row_number()==1) #only takes the first row

drop <- c("ASSOCIATION", "OBSERVER.1","OBSERVER.2","WEATHER","TEMP","ESTRUS","FOCAL.PERIOD","FOCAL.MINUTE","BEHAVIOUR","BEHAVIOUR.2","FOOD.TYPE","FOOD.Type.2","POSITION.IN.CANOPY","Position2","Position3","PLANT.SPECIES","PLANT.SPECIES.SAT.ON","G.P.S..Location","X","NOteS") #these are all the extra columns I just don't need
post_surv_edited = post_surv_edited[,!(names(post_surv_edited) %in% drop)]

post_surv_edited[17,14] = as.numeric(228) #manually changing Skittles days_surv number since she only has one focal in April, so her number needed to be changed 
```

*Survival Probability and curves with Kaplan-Meier*
```{r}
Surv(post_surv_edited$days_surv, post_surv_edited$status)[1:17] #Surv() creates a survival object for use as the response in a model formula. There will be one entry for each subject that is the survival time, which is followed by a + if the subject was censored (in this case, survived or emigrated)

#Survival curves
survfit_all <- survfit(Surv(days_surv, status) ~ 1, data = post_surv_edited) #Survfit() creates survival curves based on a formula. Let’s generate the overall survival curve for the entire cohort and look at the names
names(survfit_all) #important names are "surv" and "time"
summary(survfit_all)

#To get median survival days
survfit(Surv(days_surv, status) ~ 1, data = post_surv_edited) #The median survival days is 225

#Now let's check the probability of surviving until the end of the observations
summary(survfit(Surv(days_surv, status) ~ 1, data = post_surv_edited), times = 228) #shows us that the probability of survival at the end of data collection is 30%

#Now let's plot survfit object: Horizontal lines represent survival duration for the interval, The height of vertical lines show the change in cumulative probability, Censored observations are indicated by tick marks
plot(survfit(Surv(days_surv, status) ~ 1, data = post_surv_edited), mark.time = TRUE, 
     xlab = "Days", 
     ylab = "Overall survival probability")

ggsurvplot(
    fit = survfit(Surv(days_surv, status) ~ 1, data = post_surv_edited), 
    xlab = "Days", 
    ylab = "Overall survival probability")

#Survfit across Sex
survfit_sex<- survfit(Surv(days_surv, status) ~ SEX, data = post_surv_edited)
survfit_sex
summary(survfit_sex) #median survival time for females is 225 and 228 for males
summary(survfit_sex)$table

sum<- surv_summary(survfit_sex)
head(sum)

#Plotting for Sex
ggsurvplot(survfit_sex,
          pval = TRUE, conf.int = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_bw(), # Change ggplot2 theme
          palette = c("#E7B800", "#2E9FDF"))

#Survfit across Age
survfit_age<- survfit(Surv(days_surv, status) ~ AGE, data = post_surv_edited)
survfit_age
summary(survfit_age)$table #this still looks funky, median for adults is 210 even though none of them have that number

#Plotting for Rank - doesn't look nice
ggsurvplot(survfit_age,
          pval = TRUE, conf.int = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_bw()) # Change ggplot2 theme

#Survfit across Rank
survfit_rank<- survfit(Surv(days_surv, status) ~ rank, data = post_surv_edited)
survfit_rank
summary(survfit_rank)$table #can't get much out of this since each individual has a median survival of just how many days they survived

#Plotting for Rank - doesn't look nice
ggsurvplot(survfit_rank,
          pval = TRUE, conf.int = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_bw()) # Change ggplot2 theme

#Plotting cummulative hazard: corresponds to the number of events that would be expected for each individual by time t if the event were a repeatable process.
ggsurvplot(survfit_sex,
          conf.int = TRUE,
          risk.table.col = "strata", # Change risk table color by groups
          ggtheme = theme_bw(), # Change ggplot2 theme
          palette = c("#E7B800", "#2E9FDF"),
          fun = "cumhaz")

#Trying to do "complex survival curves" with more than one factor, this doesn't really work for me here
survfit_combo<- survfit(Surv(days_surv, status) ~ SEX + AGE, data = post_surv_edited)
survfit_combo

ggsurv <- ggsurvplot(survfit_combo, fun = "event", conf.int = TRUE,
                     ggtheme = theme_bw())
   
ggsurv$plot +theme_bw() + 
  theme (legend.position = "right")+
  facet_grid(~AGE)
```

METHODS: The average survival time was calculated using the median since survival times aren't normally distributed and the mean would be an inappropriate summary. Between-group significance tests were run using a log-rank test.  

RESULTS: The survival probability 9 months after release is 30%. The median survival time for all non-censored (confirmed or presumed dead) individuals is 225 days. The median survival time for all non-censored females and males is 225 and 228, respectively. The median survival time for all non-censorded adults and juveniles is 210(???) and 228, respectively. 

*Log-Rank Test*
```{r}
#Differences in survival times between sexes
survdiff(Surv(days_surv, status) ~ SEX, data = post_focals_surv)
#Just another way to get the same p-value
sd <- survdiff(Surv(days_surv, status) ~ SEX, data = post_focals_surv)
1 - pchisq(sd$chisq, length(sd$n) - 1)

#Differences in survival times between ages
survdiff(Surv(days_surv, status) ~ AGE, data = post_focals_surv)

#Differences in survival times across the ranks
survdiff(Surv(days_surv, status) ~ rank, data = post_focals_surv)
```

RESULTS: There is no significant difference in survival times between males and females (p= 0.08). There is a significant difference in survival times across age groups (p< 0.05). There is a significant difference in survival times across social rank (p< 0.05).

## Cox-Regression Models
```{r}
#Regression for Sex
cox_sex<- coxph(Surv(days_surv, status) ~ SEX, data = post_focals_surv) #exp(coef) = hazard ratio, which represents the ratio of hazards between two groups at any particular point in time
summary(cox_sex)

#Plotting the survival curve for sex, NOT the hazard ratio here
ggsurvplot(
    fit = survfit(Surv(days_surv, status) ~ SEX, data = post_focals_surv), 
    xlab = "Days", 
    ylab = "Overall survival probability")

#Regression for Age
cox_age<- coxph(Surv(days_surv, status) ~ AGE, data = post_focals_surv) 
summary(cox_age)

#Regression for Rank
cox_rank<- coxph(Surv(days_surv, status) ~ rank, data = post_focals_surv) 
summary(cox_rank)
```

RESULTS: The variable sex has highly statistically significant coefficients (p < 0.05). Beta coef for sex (males) = -0.10562, which indicates that males have lower risk of death than females. Being male reduces the hazard by a factor of 0.90, or 10%. The varibale age (juvenile-adult) has statistically significant coefficients (p < 0.05). Juveniles have a lower risk of death than adults. Being juvenile reduces hazard by 0.3 or 70%. The variable rank has statistically significant coefficients (p< 0.05). Regression coef (coef) is a positive value, which means the risk of death is higher for those with larger social ranking values ("lower" ranked in our case).  

*Cox Multiple regression*
```{r}
#This shows us how to factos jointly impact survival
cox_multi<- coxph(Surv(days_surv, status) ~ SEX + AGE, data = post_surv_edited) #cox-regression on age and sex
summary(cox_multi)

cox_multi2<- coxph(Surv(days_surv, status) ~ rank + SEX + AGE, data= post_surv_edited)
summary(cox_multi2)

# Plot the baseline survival function
ggsurvplot(survfit(cox_multi2), data =post_surv_edited, palette = "#2E9FDF",
           ggtheme = theme_minimal())

```

RESULTS: In the Cox multiple regression analysis, sex is no longer statistically significant (p= 0.18). The likelihood ratio test (p= 0.1), Wald test (p=0.2), and The Score (logrank) test (p= 0.07) are also not statistically significant. There is a slighly significant effect of the juvenile age category on survival (p=0.03) and rank on survival (p=0.01). When holding the other covariates constant, none of these covariates seem to have a very strong effect on the hazard ratio (or death). 

*Proportional Hazards Assumption Test and other statistical tests*
```{r}
#Testing for proportional hazards (PH) assumption:
test.ph <- cox.zph(cox_multi2)
test.ph #yay we can assume proportional hazards since these covariates don't show statistical significance, Sex is technically 0.05 with this test but comes us as 0.15 when I just run it with Sex and Age

ggcoxzph(test.ph)

#Testing influential observations 

#Specifying the argument type = “dfbeta”, plots the estimated changes in the regression coefficients upon deleting each observation in turn
ggcoxdiagnostics(cox_multi2, type = "dfbeta",
                 linear.predictions = FALSE, ggtheme = theme_bw()) #I don't fully understand this but it does seem that some of the observations are influential (mostly for rank)

#The deviance residual is a normalized transform of the martingale residual. These residuals should be roughtly symmetrically distributed about zero with a standard deviation of 1. Positive values correspond to individuals that “died too soon” compared to expected survival times. Negative values correspond to individual that “lived too long”. Very large or small values are outliers, which are poorly predicted by the model.
ggcoxdiagnostics(cox_multi2, type = "deviance",
                 linear.predictions = FALSE, ggtheme = theme_bw()) #this looks fairly symmetrical around 0 but not perfect, is this ok?

ggcoxfunctional(Surv(days_surv, status) ~ rank + log(rank) + sqrt(rank), data = post_focals_surv)
```

METHODS: Proportional hazards (PH) assumption was tested for the model as a whole as well as each covariate based on scaled Schoenfeld residuals to test for independence between residuals and time. Influential observations were also observed graphically using df beta. One influential case was discovered showing a large influence on the rank variable and removed from the analysis?? Don't know if I have to do this.

RESULTS: The PH assumption test is not statistically significance for each of the covariates, as well as the global test. A graphed diagnostic, which shows graphs of the scaled Schoenfeld residuals against the transformed time, shows no trend in the covariates across time. Therefore, we can assume proportional hazards.

## Survival Analysis Reduced - Adding in Behavioral Data
```{r}
post_focals_surv_reduced<- post_focals_surv %>%
  filter(!FOCAL.ID %in% c("RE","SK")) %>% #these two have very little behavior data post-release so removing them
  droplevels()
unique(post_focals_surv_reduced$FOCAL.ID)
```

```{r}
# 1. Create character vector of all the monkey IDs in the dataset:
monkeyIDs_surv<-as.character(unique(post_focals_surv_reduced$FOCAL.ID))

# 2. Get a list of dataframes, subsetted by monkey ID:
monkeyID_vigsurv_list<-lapply(monkeyIDs_surv, function(x){post_focals_vig[post_focals_vig[["FOCAL.ID"]] == x, ]})
head(monkeyID_vigsurv_list)

monkeyID_surv_vig<-
  monkeyID_vigsurv_list %>%
  purrr::map(~group_by(.,day,hour)) %>% #grouping by day&hour so that I get a vigilance count for each unique day-hour combination per individual 
  purrr::map(~summarize(.,count=n())) #counting up vigilance 
names(monkeyID_surv_vig)<- monkeyIDs_surv

names(monkeyID_surv_vig)
head(monkeyID_surv_vig)

monkeyID_surv_vig<- monkeyID_vigsurv_list %>%
  dplyr::mutate(.,ID = map(FOCAL.ID))
  
  purrr::map(~mean(.,count))
head(monkeyID_surv_vig)
```



## Vigilance Counts

### Filtering out each individual from the post-focals dataset
```{r}
Pops_post<- post_focals %>% filter(FOCAL.ID == "PO")
Jack_post<- post_focals %>% filter(FOCAL.ID == "JA")
Blue_post<- post_focals %>% filter(FOCAL.ID == "BL")
Amy_post<- post_focals %>% filter(FOCAL.ID == "AM")
Alex_post<- post_focals %>% filter(FOCAL.ID == "AL")
Bgm_post<- post_focals %>% filter(FOCAL.ID == "BM")
Nev_post<- post_focals %>% filter(FOCAL.ID == "NE")
Mango_post<- post_focals %>% filter(FOCAL.ID == "MG")
Eddy_post<- post_focals %>% filter(FOCAL.ID == "ED")
May_post<- post_focals %>% filter(FOCAL.ID == "MA")
Kovu_post<- post_focals %>% filter(FOCAL.ID == "KO")
Tink_post<- post_focals %>% filter(FOCAL.ID == "TI")
Toni_post<- post_focals %>% filter(FOCAL.ID == "TO")
Boo_post<- post_focals %>% filter(FOCAL.ID == "BO")
Aug_post<- post_focals %>% filter(FOCAL.ID == "AU")
Cic_post<- post_focals %>% filter(FOCAL.ID == "CI")
Homer_post<- post_focals %>% filter(FOCAL.ID == "HO")
```

### Post-Release Vigilance Counts from each Individual
```{r}
Pops_vig2<- Pops_post %>% 
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% #filtering out only the vigilance behavior from this new "behavior" column created by gather()
  summarize(count=n()) #counting all the vigilance entries
Pops_vig2$prop<- Pops_vig2$count/nrow(Pops_post)
Pops_vig2$ID<- "Pops"

Jack_vig2<- Jack_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Jack_vig2$prop<- Jack_vig2$count/nrow(Jack_post)
Jack_vig2$ID<- "Jack"

Blue_vig2<- Blue_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Blue_vig2$prop<- Blue_vig2$count/nrow(Blue_post)
Blue_vig2$ID<- "Blue"

Alex_vig2<- Alex_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Alex_vig2$prop<- Alex_vig2$count/nrow(Alex_post)
Alex_vig2$ID<- "Alex"

Nev_vig2<- Nev_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Nev_vig2$prop<- Nev_vig2$count/nrow(Nev_post)
Nev_vig2$ID<- "Neville"

Aug_vig2<- Aug_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Aug_vig2$prop<- Aug_vig2$count/nrow(Aug_post)
Aug_vig2$ID<- "Aug"

Amy_vig2<- Amy_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Amy_vig2$prop<- Amy_vig2$count/nrow(Amy_post)
Amy_vig2$ID<- "Amy"

May_vig2<- May_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
May_vig2$prop<- May_vig2$count/nrow(May_post)
May_vig2$ID<- "May"

Toni_vig2<- Toni_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Toni_vig2$prop<- Toni_vig2$count/nrow(Toni_post)
Toni_vig2$ID<- "Toni"

Boo_vig2<- Boo_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Boo_vig2$prop<- Boo_vig2$count/nrow(Boo_post)
Boo_vig2$ID<- "Boo"

Bgm_vig2<- Bgm_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Bgm_vig2$prop<- Bgm_vig2$count/nrow(Bgm_post)
Bgm_vig2$ID<- "Big Mama"

Kovu_vig2<- Kovu_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Kovu_vig2$prop<- Kovu_vig2$count/nrow(Kovu_post)
Kovu_vig2$ID<- "Kovu"

Ed_vig2<- Eddy_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Ed_vig2$prop<- Ed_vig2$count/nrow(Eddy_post)
Ed_vig2$ID<- "Eddy"

Tink_vig2<- Tink_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Tink_vig2$prop<- Tink_vig2$count/nrow(Tink_post)
Tink_vig2$ID<- "Tinker"

Mango_vig2<- Mango_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Mango_vig2$prop<- Mango_vig2$count/nrow(Mango_post)
Mango_vig2$ID<- "Mango"

Cic_vig2<- Cic_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Cic_vig2$prop<- Cic_vig2$count/nrow(Cic_post)
Cic_vig2$ID<- "Cicero"

Homer_vig2<- Homer_post %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
Homer_vig2$prop<- Homer_vig2$count/nrow(Homer_post)
Homer_vig2$ID<- "Homer"
```

*Creating a vigilance dataframe*
```{r}
vig2_df_ALL<- list(Pops_vig2, Jack_vig2, Blue_vig2, Alex_vig2, Nev_vig2, Aug_vig2, Amy_vig2, May_vig2, Toni_vig2, Boo_vig2, Bgm_vig2, Kovu_vig2, Ed_vig2, Tink_vig2, Mango_vig2) #leaving out Cicero and Homer here because they're wild males
vig2_df_ALL<- Reduce(function(x, y) merge(x, y, all=TRUE), vig2_df_ALL, accumulate=FALSE) #this changes it from a "list" item to an actual data frame
str(vig2_df_ALL)

#Adding a "sex" column
vig2_df_ALL<- vig2_df_ALL %>% 
  add_column(sex = c("M","F","F","M","M","F","F","F","F","F","F","F","F","F", "M"), .after="ID")
```

*Plotting the vigilance dataframe*
```{r}
ggplot(vig2_df_ALL, aes(x = reorder(ID, -prop), y = prop), fill= sex) + #the reorder function with -prop reorders the x-axis to go from highest to lowest
  geom_bar(stat = "identity") + 
  scale_y_continuous(labels=scales::percent) + #this changes the y-axis to percents
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + #turns axis labels to 45 degrees and hjust get rid of excess space
  ylab("Percent Vigilance Behavior") +
  xlab("Individual") +
  scale_fill_manual("legend", values = c("F" = "red", "M" = "blue")) #doesn't want to work
```

*Post-release Vigilance across entire troop*
```{r}
post_focals_vig<- post_focals %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>%
  group_by(behavior) %>% 
  filter(behavior == "V") %>% 
  summarize(count=n())
post_focals_vig$prop<- post_focals_vig$count/nrow(post_focals)
```

### Vigilance Dataframe Editing
```{r}
#first filtering out all of the individuals that have little or no focal data post-release
post_focals_edited<- post_focals %>%
  rename(day = DAY, hour= TIME..HOUR.) %>%
  filter(!FOCAL.ID %in% c("PA","ZI","RE","SK","HO","CI")) %>%
  droplevels()

#creating a "vigilance-only" dataframe
post_focals_vig<- post_focals_edited %>%
  gather("Obs", "behavior", 20:21, na.rm = T) %>% #combining behavior1&2
  group_by(behavior) %>% 
  filter(behavior == "V") #pulling out vigilance
```

### Rate of Vigilance for ADULT FEMALES
```{r}
#1. Create a new dataframe with adult females only
post_focals_Afems<- post_focals_edited %>%
  filter(SEX == "F", AGE == "A")

#2. create a character list of all adult female IDs
MonkeyIDs_postAfems<- as.character(unique(post_focals_Afems$FOCAL.ID))
MonkeyIDs_postAfems

# 2. Get a list of dataframes (from the updated vigilance dataframe), subsetted by adult female monkey ID
monkey.list_postAfems<-lapply(MonkeyIDs_postAfems, function(x){post_focals_vig[post_focals_vig[["FOCAL.ID"]] == x, ]})
head(monkey.list_postAfems)

#3. Create new list of tibbles to look at vigilance counts per hour 
monkey.list_post_vigAfems<-
  monkey.list_postAfems %>%
  purrr::map(~group_by(.,day,hour)) %>% #grouping by day&hour so that I get a vigilance count for each unique day-hour combination per individual 
  purrr::map(~summarize(.,count=n())) #counting up vigilance 
head(monkey.list_post_vigAfems)

#4. Combining all the tibbles into one
monkey.list_post_vigAfems<- monkey.list_post_vigAfems %>% 
  purrr::reduce(dplyr::full_join) %>% #using full_join since all columns are the same across tibbles
  mutate(release = "post") #creating a new column called "release"
monkey.list_post_vigAfems
mean(monkey.list_post_vigAfems$count) #7.16
```

*Pre/Post Adult Female Vigilance Tibble*
```{r}
monkey.list_vigAfems_FULL<- full_join(monkey.list_post_vigAfems, monkey.list_pre_vigAfems) #joining the two vigilance tibbles together
```

### Testing for Adult Female Vigilance Normality
```{r}
#calculating the difference between release stages to test for normality
x <- with(monkey.list_vigAfems_FULL, 
        count[release == "post"] - count[release == "pre"])
# Shapiro-Wilk normality test for the differences
shapiro.test(x)

#Looking at density plots and qqplots to check for normality
ggdensity(monkey.list_vigAfems_FULL$count)
ggqqplot(monkey.list_vigAfems_FULL$count)

#Plotting pre and post vigilance rates 
ggplot(monkey.list_vigAfems_FULL, aes(x=release, y=count, color=release)) +
  geom_boxplot(outlier.color = "black", notch = TRUE) +
  scale_x_discrete(limits=c("pre", "post")) +
  labs(x= "Release Stage", y= "Average rate of vigilance")
  

#Running log10 transformations to see if that changes distribution
log<- log10(monkey.list_vigAfems_FULL$count)
shapiro.test(log)
ggdensity(log)
ggqqplot(log)
```

METHODS: To test for normality, Shapiro-Wilk tests were performed on hourly vigilance rate data for each age/sex category. Where Shapiro-Wilk tests revealed non-normal distributions, Log10 transformations were conducted and normality was reassessed. When Log10 transformations also showed non-normal distribution, non-parametric tests were run on the un-logged variables. 

The Log10 transformations for 1) adult female, 2) subadult & juvenile, and 3) Pops hourly vigilance rates show non-normal distribution.

### Wilcoxon Test for Adult Fems
```{r}
#Doing a unpaired two-sample Wilcoxon test because I get an error when I do it paired
WT_vigAfems<- wilcox.test(count ~ release, data = monkey.list_vigAfems_FULL, exact = TRUE)
WT_vigAfems

#add in ID names as row names
#When paired = TRUE, I get an error that x and y need to be the same length
```

RESULTS: There is a significant difference in mean hourly vigilance rates of adult females pre- and post-release. 

### Rate of Vigilance for Subadults and Juveniles
```{r}
#1. Create a new dataframe with SA & juvs only
post_focals_young<- post_focals_edited %>%
  filter(AGE %in% c("SA","J"))

#2. create a character list of all SA & juvs
MonkeyIDs_postyoung<- as.character(unique(post_focals_young$FOCAL.ID))
MonkeyIDs_postyoung

# 2. Get a list of dataframes (from the updated vigilance dataframe), subsetted by monkey ID
monkey.list_postyoung<-lapply(MonkeyIDs_postyoung, function(x){post_focals_vig[post_focals_vig[["FOCAL.ID"]] == x, ]})
head(monkey.list_postyoung)

#3. Create new list of tibbles to look at vigilance counts per hour 
monkey.list_post_vigyoung<-
  monkey.list_postyoung %>%
  purrr::map(~group_by(.,day,hour)) %>% #grouping by day&hour so that I get a vigilance count for each unique day-hour combination per individual 
  purrr::map(~summarize(.,count=n())) #counting up vigilance 
head(monkey.list_post_vigyoung)

#4. Combining all the tibbles into one
monkey.list_post_vigyoung<- monkey.list_post_vigyoung %>% 
  purrr::reduce(dplyr::full_join) %>% #using full_join since all columns are the same across tibbles
  mutate(release = "post") #creating a new column called "release"
monkey.list_post_vigyoung
mean(monkey.list_post_vigyoung$count) #6.59
```

*Pre/Post Subadult & Juvenile Vigilance Tibble*
```{r}
monkey.list_vigyoung_FULL<- full_join(monkey.list_post_vigyoung, monkey.list_pre_vigyoung) #joining the two vigilance tibbles together
monkey.list_vigyoung_FULL
```

### Testing for Subadult & Juvenile Vigilance Normality
```{r}
#calculating the difference between release stages to test for normality
x2 <- with(monkey.list_vigyoung_FULL, 
        count[release == "post"] - count[release == "pre"])
# Shapiro-Wilk normality test for the differences
shapiro.test(x2)

#Looking at density plots and qqplots to check for normality
ggdensity(monkey.list_vigyoung_FULL$count)
ggqqplot(monkey.list_vigyoung_FULL$count)

#Plotting pre and post vigilance rates 
ggplot(monkey.list_vigyoung_FULL, aes(x=release, y=count, color=release)) +
  geom_boxplot(outlier.color = "black", notch = TRUE) +
  scale_x_discrete(limits=c("pre", "post")) +
  labs(x= "Release Stage", y= "Average rate of vigilance")

#Running log10 transformations to see if that changes distribution
log2<- log10(monkey.list_vigyoung_FULL$count)
shapiro.test(log2)
ggdensity(log2)
ggqqplot(log2)
```

### Wilcoxon Test for Subs/Juvs
```{r}
#Doing a unpaired two-sample Wilcoxon test because I get an error when I do it paired
WT_vigyoung<- wilcox.test(count ~ release, data = monkey.list_vigyoung_FULL, exact = FALSE)
WT_vigyoung

#When paired = TRUE, I get an error that x and y need to be the same length
```

RESULTS: There is a significant difference in mean hourly vigilance rates of subadults and juveniles pre- and post-release. 

### Rate of Vigilance for Pops
```{r}
post_focals_vigPops<- post_focals_vig %>%
  filter(FOCAL.ID == "PO") %>%
  group_by(day,hour) %>%
  summarize(count=n()) %>%
  mutate(release = "post")
  
mean(post_focals_vigPops$count) #8.38
```

*Pre/Post Pops Vigilance Tibble*
```{r}
post_focals_vigPops_FULL<- full_join(post_focals_vigPops, pre_focals_vigPops) #joining the two vigilance tibbles together
post_focals_vigPops_FULL
```

### Testing for Pops Normality
```{r}
#calculating the difference between release stages to test for normality
x3 <- with(post_focals_vigPops_FULL, 
        count[release == "post"] - count[release == "pre"])
# Shapiro-Wilk normality test for the differences
shapiro.test(x3)
shapiro.test(post_focals_vigPops_FULL$count)

#Looking at density plots and qqplots to check for normality
ggdensity(post_focals_vigPops_FULL$count)
ggqqplot(post_focals_vigPops_FULL$count)

#Plotting pre and post vigilance rates 
ggplot(post_focals_vigPops_FULL, aes(x=release, y=count, color=release)) +
  geom_boxplot(outlier.color = "black", notch = TRUE) +
  scale_x_discrete(limits=c("pre", "post")) +
  labs(x= "Release Stage", y= "Average rate of vigilance")

#Running log10 transformations to see if that changes distribution
log3<- log10(post_focals_vigPops_FULL$count)
shapiro.test(log3)
ggdensity(log3)
ggqqplot(log3)
```

### Wilcoxon Test
```{r}
#Doing a unpaired two-sample Wilcoxon test because I get an error when I do it paired
WT_vigPops<- wilcox.test(count ~ release, data = post_focals_vigPops_FULL, exact = FALSE)
WT_vigPops

#When paired = TRUE, I get an error that x and y need to be the same length
```

RESULTS: There is a significant difference in Pop's mean hourly vigilance rates pre- and post-release. 

```{r}
shapiro.test(monkey.list_pre_vigAfems$count)
histogram(monkey.list_pre_vigAfems$count)


```

## Social Network Code:
```{r}
# 1. Create a character vector of all the focal IDs in your dataset:
pre_sn_closeIDs<-as.character(unique(pre_socnet_close$Focal.ID))

# 2. Get a list of dataframes, subsetted by monkey ID:
pre_sn_monkeylist<-lapply(pre_sn_closeIDs, function(x){pre_socnet_close[pre_socnet_close[["Focal.ID"]] == x, ]})
head(pre_sn_monkeylist) #this will load the first 6 lists, take a look at them and see that each is for an individual monkey

# 3. Group each by focal/associate, and count how many times they are observed close together:
pre_sn_grouped<-
  pre_sn_monkeylist %>%
  purrr::map(~group_by(.,Association)) %>%
  purrr::map(~summarize(.,count=n())) 
names(pre_sn_grouped) <- pre_sn_closeIDs #this will give each grouped list the name of the Focal ID

# 4. Set up your pairwise combinations of interacting monkeys:
pre_sn_monkeycombos<-list(focal=pre_sn_closeIDs, associate=pre_sn_closeIDs) #create list of all possible focals/associates
pre_sn_filt<- function(x, y) {x == y} #create function to filter out same-monkey pairs ("PO is close to PO")
pre_sn_combo<- pre_sn_monkeycombos %>% cross_df(.,.filter=pre_sn_filt) #get the filtered combined list as a dataframe
head(pre_sn_combo)

pre_sn_combo2<-
  pre_sn_combo %>%
  mutate(absent1 = map2_chr(
    focal,
    associate,
    ~if_else(.x %in% names(pre_sn_grouped),true="TRUE",false="FALSE"))) %>%
    mutate(absent2 = map2_chr(
    focal,
    associate,
    ~if_else(.y %in% pre_sn_grouped[[.x]]$Association,true="TRUE",false="FALSE"))) %>%
  filter(absent1 == "TRUE") %>%
  filter(absent2 == "TRUE") %>%
  dplyr::select(-absent1,-absent2)

pre_sn_combo3<- pre_sn_combo2 %>% 
  mutate(proximity = map2_int(
    focal, 
    associate, 
    ~pre_sn_grouped %>% pluck(.x) %>% filter(Association==.y) %>% as.data.frame(.) %>% .[,2]))
pre_sn_combo3

pre_sn_matrix<-spread(pre_sn_combo3,associate,proximity) %>% column_to_rownames(var="focal") %>% data.matrix()
pre_sn_matrix
```
